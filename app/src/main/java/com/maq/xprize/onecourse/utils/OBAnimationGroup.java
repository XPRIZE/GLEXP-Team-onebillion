package com.maq.xprize.onecourse.utils;

import android.graphics.RectF;
import android.os.AsyncTask;
import android.os.SystemClock;

import com.maq.xprize.onecourse.controls.OBControl;
import com.maq.xprize.onecourse.mainui.OBSectionController;

import java.util.List;

import android.view.animation.AccelerateDecelerateInterpolator;
import android.view.animation.AccelerateInterpolator;
import android.view.animation.DecelerateInterpolator;
import android.view.animation.Interpolator;
import android.view.animation.LinearInterpolator;

import static com.maq.xprize.onecourse.mainui.OBSectionController.PROCESS_DONE;
import static com.maq.xprize.onecourse.mainui.OBSectionController.PROCESS_NOT_DONE;
import static com.maq.xprize.onecourse.utils.OBAnim.ANIM_EASE_IN_EASE_OUT;

/**
 * OBAnimationGroup
 * Runs the animations generated by the OBAnim constructors.
 * Can run animations in sequence or in parallel;
 *
 * @see OBAnim
 * Created by alan on 20/11/15.
 */

public class OBAnimationGroup
{
    public final static int ANIM_CANCEL = 1;
    public int flags;
    List<OBAnim> animations;
    double startTime,duration;
    long startms;
    OBSectionController owner;
    Interpolator interpolator;
    int chainIndex = 0;
    RectF r1;
    RectF r2;
    boolean resetOnLoop;
    public OBConditionLock lock;

    public static OBAnimationGroup runAnims(final List<OBAnim> anims,final double secs,boolean wait,final int timingFunction,final OBSectionController vc)
    {
        return runAnims(anims,secs,wait,timingFunction,null,vc);
    }

    public static OBAnimationGroup runAnims(final List<OBAnim> anims, final double secs, boolean wait, final int timingFunction, final OBUtils.RunLambda completionBlock, final OBSectionController vc)
    {
        final OBAnimationGroup ag = new OBAnimationGroup();
        if (wait)
        {
            ag.applyAnimations(anims,secs,timingFunction,vc);
            if(completionBlock != null)
            {
                try
                {
                    completionBlock.run();
                }
                catch (Exception e)
                {

                }
            }
        }
        else
        {
            new AsyncTask<Void, Void, Void>()
            {
                @Override
                protected Void doInBackground(Void... params)
                {
                    ag.applyAnimations(anims,secs,timingFunction,vc);
                    if(completionBlock != null)
                    {
                        try
                        {
                            completionBlock.run();
                        }
                        catch (Exception e)
                        {

                        }
                    }
                    return null;
                }
            }.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, (Void[]) null);

        }

        return ag;
    }


    public static OBAnimationGroup chainAnimations(List<List<OBAnim>> animArrays,List<Float>durations,boolean wait,List<Integer>timingFunctions,int noLoops,OBSectionController vc)
    {
        OBAnimationGroup ag = new OBAnimationGroup();
        ag.chainAnimations(animArrays,durations,timingFunctions,noLoops,vc,wait, null);
        return ag;
    }

    public static OBAnimationGroup chainAnimations(List<List<OBAnim>> animArrays, List<Float>durations, boolean wait, List<Integer>timingFunctions, int noLoops, OBUtils.RunLambda completionBlock, OBSectionController vc)
    {
        OBAnimationGroup ag = new OBAnimationGroup();
        ag.chainAnimations(animArrays,durations,timingFunctions,noLoops,vc,wait,completionBlock);
        return ag;
    }

    public void OBAnimationGroup()
    {

    }

    void doFrame(double frac)
    {
        final float t = (float)OB_Maths.clamp01(interpolator.getInterpolation((float)frac));
        //final float t = OB_Maths.bezef((float)frac);


            if(owner != null)
                owner.lockScreen();
            for (OBAnim anim : animations)
            {
                Object val = anim.valueForT(t);
                if (anim.typeType == OBAnim.ANIM_TYPE_BLOCK)
                    ((OBAnimBlock)anim).runAnimBlock(t);
                else
                {
                    try
                    {
                        anim.setter.invoke(anim.object,val);
                    }
                    catch (Exception e)
                    {
                    }
                }
            }
            if(owner != null)
                owner.unlockScreen();


    }
    void startAnimations(int timingFunction)
    {
        if (timingFunction == ANIM_EASE_IN_EASE_OUT)
            interpolator = new AccelerateDecelerateInterpolator();
        else if (timingFunction == OBAnim.ANIM_EASE_IN)
            interpolator = new AccelerateInterpolator();
        else if (timingFunction == OBAnim.ANIM_EASE_OUT)
            interpolator = new DecelerateInterpolator();
        else
            interpolator = new LinearInterpolator();
        r1 = new RectF();
        r2 = new RectF();
        for (OBAnim anim : animations)
        {
            anim.retrieveInitialValue();
        }
        startms = SystemClock.uptimeMillis();
    }

    public boolean doFrameForTime()
    {
        long currtime = SystemClock.uptimeMillis();
        double frac;
        if (duration == 0)
            frac = 1.1;
        else
            frac = (currtime - startms) / (duration * 1000);
        doFrame(OB_Maths.clamp01(frac));
        try
        {
            Thread.sleep(20);
        }
        catch (InterruptedException e)
        {
        }
        return frac <= 1.0;
    }
public void applyAnimations(List<OBAnim>anims,double dur,int timingFunction,OBSectionController vc)
    {
        duration = dur;
        animations = anims;
        owner = vc;
        startAnimations(timingFunction);
        double frac = 0;
        while (frac <= 1.0 && (flags & ANIM_CANCEL) == 0)
        {
            long currtime = SystemClock.uptimeMillis();
            if (duration == 0)
                frac = 1.1;
            else
                frac = (currtime - startms) / (duration * 1000);
            doFrame(OB_Maths.clamp01(frac));
            if (owner == null)
                try
                {
                    Thread.sleep(10);
                }
                catch (InterruptedException e)
                {
                }
            else
                owner.waitForSecsNoThrow(0.01);
        }
        if (this.lock != null)
        {
            this.lock.lock();
            this.lock.unlockWithCondition(PROCESS_DONE);
        }
    }

    public void applyAnimations(final List<OBAnim>anims,final double dur,boolean wait,final int timingFunction,final OBSectionController vc)
    {
        if (wait)
        {
            lock = new OBConditionLock(PROCESS_NOT_DONE);
            //
            applyAnimations(anims, dur, timingFunction, vc);
            //
            lock.lockWhenCondition(PROCESS_DONE);
            lock.unlock();
        }
        else
            new AsyncTask<Void, Void, Void>()
            {
                @Override
                protected Void doInBackground(Void... params)
                {
                    applyAnimations(anims, dur,timingFunction,vc);
                    return null;
                }
            }.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, (Void[]) null);

    }

    public void applyAnimations(List<OBAnim>anims,float secs,int timingFunction,int noLoops, OBUtils.RunLambda completionBlock,final OBSectionController vc)
    {

        while (noLoops != 0)
        {
            if ((flags & ANIM_CANCEL) != 0)
                break;
            applyAnimations(anims,secs,true,timingFunction,vc);
            if (noLoops > 0)
                noLoops--;
            if (resetOnLoop && noLoops != 0)
            {
                for (OBAnim anim : anims)
                {
                    if (anim.initialValue != null)
                        ((OBControl)anim.object).setProperty(anim.key,anim.initialValue);
                }
            }
        }
        if (completionBlock != null)
            try {
                completionBlock.run();
            } catch (Exception e) {
                e.printStackTrace();
            }
    }

    public void applyAnimations(final List<OBAnim>anims,final float secs,final boolean wait,final int timingFunction,final int noLoops, final OBUtils.RunLambda completionBlock,final OBSectionController vc)
    {
        if (wait)
            applyAnimations(anims,secs,timingFunction,noLoops,completionBlock,vc);
        else
            OBUtils.runOnOtherThread(new OBUtils.RunLambda() {
                @Override
                public void run() throws Exception {
                    applyAnimations(anims,secs,timingFunction,noLoops,completionBlock,vc);
                }
            });
    }
    public void chainAnimations(List<List<OBAnim>> animArrays,List<Float>durations,List<Integer>timingFunctions,int noLoops,OBSectionController vc)
    {
        float durValue = 1;
        int timingValue = ANIM_EASE_IN_EASE_OUT;
        while (noLoops != 0)
        {
            for (int i = 0;i < animArrays.size();i++)
            {
                if ((flags & ANIM_CANCEL) != 0)
                {
                    noLoops = 0;
                    break;
                }
                if (i < durations.size())
                    durValue = durations.get(i);
                if (i < timingFunctions.size())
                    timingValue = timingFunctions.get(i);
                applyAnimations(animArrays.get(i),durValue,timingValue,vc);
            }
            if (noLoops > 0)
                noLoops--;
        }
    }

    public void chainAnimations(List<List<OBAnim>> animArrays, List<Float>durations, List<Integer>timingFunctions, int noLoops, OBSectionController vc, boolean wait)
    {
        chainAnimations(animArrays,durations,timingFunctions,noLoops,vc,wait,null);
    }


    public void chainAnimations(List<List<OBAnim>> animArrays, List<Float>durations, List<Integer>timingFunctions, int noLoops, OBSectionController vc, boolean wait, final OBUtils.RunLambda completionBlock)
    {
        if (wait)
        {
            chainAnimations(animArrays, durations, timingFunctions, noLoops, vc);
            if(completionBlock != null)
            {
                try
                {
                    completionBlock.run();
                }
                catch (Exception e)
                {

                }
            }
        }
        else
        {
            final List<List<OBAnim>> fanimArrays = animArrays;
            final List<Float>fdurations = durations;
            final List<Integer>ftimingFunctions = timingFunctions;
            final int fnoLoops = noLoops;
            final OBSectionController fvc = vc;
            new AsyncTask<Void, Void, Void>()
            {
                protected Void doInBackground(Void... params)
                {
                    chainAnimations(fanimArrays, fdurations, ftimingFunctions, fnoLoops, fvc);
                    if(completionBlock != null)
                    {
                        try
                        {
                            completionBlock.run();
                        }
                        catch (Exception e)
                        {

                        }
                    }
                    return null;
                }
            }.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, (Void[]) null);
        }
    }

}
